---
publish: false
date: 2025-09-23 10:30:00
tags:
   - 秋招
   - 腾讯
   - 前端
   - 面试
---

# 腾讯秋招二面

1. 自我介绍。
2. Base 确认。
3. 更详细地介绍实习情况。
4. 低代码平台背景？
5. 解决 If-else 的设计模式？
6. 生成页面的数据如何存储？
7. 目前低代码的设计，比如组件等依赖特定的语言框架，怎么优化？

   :::tip 📌 回答
   - 首先，我认为可以参考微前端、微组件这些概念，页面的框架差异交给微前端来抹平、组件等的差异利用微组件、微模块、Web Components 等来解决。
   - 也可以定制自己的 DSL，比如实习期间用到的元数据，所有的数据存储都转换成自定义的这一层，用对应的数据结构来处理。高级一点，对于 Runtime API 处理通用性，比如最后都转换成 Wasm 的调用。
   - 更暴力的，可以不存储 React 或者 Vue 对应的 DOM 等结构，直接用前端原生来存储。

   | 策略                                 | 解决的问题                     | 优点                                                                              | 缺点 / 风险                                                                      | 适用场景                                                   | 工程实践建议                                                                                                             |
   | ------------------------------------ | ------------------------------ | --------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
   | 微前端 / 微组件 / Web Components | 页面或组件在不同框架间无法共存 | - 页面级或组件级隔离<br>- 支持多框架共存<br>- 对现有框架依赖少                    | - 性能开销高（多个运行时）<br>- 组件通信复杂<br>- 微前端粒度过小可能带来维护成本 | - 页面级隔离<br>- 需要混合 React / Vue / Angular 页面      | - 选择成熟微前端框架如 Garfish / qiankun<br>- 对通信和共享状态做统一封装<br>- 对微组件统一注册机制                       |
   | 自定义 DSL / 元数据层            | 组件和页面逻辑高度依赖框架     | - 框架无关<br>- 易做版本管理和撤销重做<br>- 可在编辑器和渲染器之间通用            | - DSL 设计复杂，需要全局统一规范<br>- 逻辑层与渲染层需要适配                     | - 需要高度可视化编辑<br>- 多框架渲染器适配                 | - 统一元数据 schema，定义清晰节点属性/事件/层级<br>- 编辑器操作直接操作 DSL<br>- 渲染器负责把 DSL 转成 React/Vue/WebComp |
   | 原生存储 / Runtime API / WASM    | 组件逻辑绑定框架导致复用性差   | - 最大程度跨框架可复用<br>- 可以将业务逻辑独立<br>- 未来可考虑多语言跨平台        | - 实现成本高<br>- 调试和可视化体验可能差<br>- 对框架特性支持有限                 | - 平台逻辑复杂，需要统一调度<br>- 想做语言无关或跨框架逻辑 | - 统一 Runtime API（setState、dispatch、subscribe）<br>- DSL 转 Runtime API 调用<br>- 高级可以编译成 WASM 逻辑模块       |
   | 混合方案（推荐）                 | 综合解决三类问题               | - DSL + 微组件组合，既可跨框架又易编辑<br>- 原生存储或 Runtime API 提高逻辑复用性 | - 系统复杂度高，需要多层封装                                                     | - 大型低代码平台                                           | - DSL 描述 UI 树 + 属性<br>- 微组件做粒度复用<br>- Runtime API 做逻辑抽象<br>- 渲染器可以根据目标框架选择实现            |

   :::

8. 解释型语言和编译型语言的含义、区别、现状？

   :::tip 📌 回答
   - 解释型语言，是指运行时环境会解释代码并直接执行，比如 Python、JavaScript 等；编译型语言，是指编译时将代码转换成机器码之后再执行，比如 C、Java 等。
   - 解释型语言的执行速度不如编译型语言，但是调试更方便、开发更快捷。
   - 现状就是二者的边界正在交融，浏览器有 JIT 技术，能利用即时编译讲 JS 部分代码转换成本地机器码；而 Go/Java 等也支持部分即时执行或 VM。另外，WebAssembly 出现，可以允许其他编译型语言生成的字节码文件在浏览器中运行。
   :::

9.  32 位操作系统的最大内存？如果有一个软件的运行时占用了 4G 内存，那么这个软件是否会崩溃？

   :::tip 📌 回答
   现代 OS 可以用虚拟内存缓冲，但一旦总虚拟内存也不足，或者大块连续内存无法分配 → 崩溃不可避免
   :::


10. 手写反转链表。
11. 实习经历和广告相关的部分有哪些？
12. 为什么还在看其他的机会？留用情况如何？目前的意向？
13. 什么专业？选择前端开发的原因？
14. 和 UI 反复修改会不会觉得繁琐无聊？
15. 讲一讲字节里的 UI 向代码转化的工具？参与还是懂原理？
16. AI 对前端的冲击非常大，你怎么认为？AI 的学习能力比人强，你又怎么看？
17. 手写二叉树最小深度。
18. 「反问」后续业务发展、期望、困难。